## 高性能网站建设指南

### 本书主旨

阐明如何通过修改前端来改善网站性能

### 灵活运用

本书介绍 14 个性能优化规则，但是并非每个规则都要应用于每个网站，也不是每个网站都应该按照同一种方式运行一个规则，但每个规则都值得考虑；

### 绪言

#### 前端性能的重要性

事实上，通常只有 10% ~ 20% 的最终用户响应时间是花在从 Web 服务器获取 HTML 文档并传送到浏览器中的。
如果希望有效减少页面的响应时间，必须关注剩余 80% ~ 90% 的最终用户体验；

而仅需花费 10% ~ 20% d的响应时间来下载 HTML 文档，80% ~ 90% 的时间花费在页面的组件上；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-a2bfdf187a7ffe4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 第 1 章 减少 HTTP 请求

性能黄金法则揭示：只有 10% ~ 20% 的响应时间花费在接收所请求的 HTML 文档上，80% ~ 90% 的时间花费在为 HTML 文档所引用的组件（图片、脚本、样式表和 Falsh）上进行的 HTTP 请求上。

因此，改善响应时间的最简单途径就是减少组件的数量，由此就是减少 HTTP 请求的数量。

#### 图片地图 Image Maps

对于特定的小图片，可以使用图片地图技术将多张图片整合为一张以此减少 HTTP 请求；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-3daac0808e385efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

图片地图有两种类型：
- 服务器端图片地图
原理是将所有点击提交到同一个 URL ，然后传入用户点击的 x、y 坐标，Web 应用程序将其映射为适当的操作；

- 客户端图片地图
原理是通过 MAP 标签构建出不同矩形的区域，通过点击不同的区域映射不同的操作；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-ba1229e8fbcf8e99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

图片地图的缺点是：

在定义图片地图的区域坐标时，采用手工方式很容易出错，并且只能定义矩形的形状；
同时，图片地图要求各个图片必须连续，一旦图片发生改变，需要修改整个图；

#### CSS Sprites

CSS Sprites 的原理是将多张小图整合为一张合成图，然后通过给不同元素设置 **background-position** 去指定 CSS Sprites 的偏移量；

#### 内联图片 Inline Images

通过 data: URL 模式可以在 Web 页面中包含图片而无需额外的 HTTP 请求；

其格式为：
```
data:[<mediatype>][;base64],<data>
```

![image.png](http://upload-images.jianshu.io/upload_images/1993435-dd389f6f9b859487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

由于 data: URL 内联在页面中，在切换不同页面时不会缓存，所以一些变动不大的图片，如（公司 Logo），一般是使用 外部 CSS 并将内联图片作为背景；

虽然将内联图片放置在外部样式表中额外增加一个 HTTP 请求，但被缓存后可以得到额外的收益；

#### 合并脚本和样式表

如果将脚本和样式表分开到多个小文件，则每个文件都需要一个额外的 HTTP 请求，因此可以将这些单独的文件合并到一个文件中，减少 HTTP 请求以缩短最终的用户响应时间；

【注】对于 SPA 而言，由于 JS 的体量较大，在加载脚本时可能会让用户响应时间过长，因此出现了另一种分离脚本的技术，即按需加载；

### 第 2 章 使用内容分发网络

通过 HTTP 请求的响应时间也和 Web 服务器距离用户地理位置的距离相关；
但是，不要尝试使用分布式架构重新设计 Web 应用程序，因为这回带来复杂、繁重的任务，比如同步会话状态和服务器纺织地点之间复制数据库事务等；

因此，与其重新设计应用程序这一艰难任务，以便应用程序 Web 服务器分散开，不如将组件 Web 服务器分散开，CDN 就是为了满足这一需求产生的；

CDN 是一组分布在多个不同地理位置的 Web 服务器，用于更加有效地向用户发布内容。

#### 优点
CDN 除了可以缩短响应时间外，还可以备份、扩展存储能力和进行缓存；

#### 缺点
CDN 服务提供商向所有客户共享其 Web 服务器组，因此你的响应时间可能受到其他人的影响；

你无法直接控制组件服务器从而带来特殊麻烦，比如修改 HTTP 响应头需要通过服务提供商；

### 第 3 章 缓存控制

本章节介绍如何配置组件，使其能够最大化地利用浏览器缓存能力来改善页面性能；

Web 服务器使用 Expires 响应头来告诉 Web 客户端它可以使用组件的当前副本，直到指定时间为止；
Expires 头能够使得浏览器在后续遇到相同的请求时发现资源未过期，由此 HTTP 请求数量减少一个；
Expires 头的缺点在于使用了一个特定的时间，这要求服务器和客户端的时钟严格保持同步；

另一种方式是通过 Cache-Control: max-age=xxx 来指定组件被缓存多久，具体讲师是第一次被请求时服务器记录的Request_time;

但是 Cache-Control 是 HTTP 1.1 版本提供的响应头，因此为了向后兼容，可以同时指定 Expries 和 Cache-Control，如果同时出现，则 max-age 指令重写 Expries 头；

### 第 4 章 压缩组件

本章介绍如何使用 gzip 编码来压缩 HTTP 响应报，并由此减少网络响应时间；

gzip 是目前最流行和最有效的压缩方法，是 GNU ;

Web 客户端通过 HTTP 请求头中的 Accept-Encoding 来标识对压缩的支持
```
Accept-Encoding: gzip;deflate
```
Web 服务器通过响应头中 Content-Encoding 来通知 Web 客户端：
```
Content-Encoding: gzip
```

通常，包括 HTML、XML、JSON 在内的文本以及脚本和样式表都是值得压缩的，而图片和 PDF 不应该压缩因为它们本来就已被压缩，再次压缩只会浪费 CPU 资源还有可能增加文件大小；

#### 代理缓存

当浏览器通过代理来发送请求，情况就变得复杂；

假设一个请求发送到代理是来自不支持 gzip 的浏览器，代理会将请求转发给 Web 服务器，此时服务器的响应是未经压缩的；

现在，到达代理的第 2 个请求访问的是同一个 URL，但来自一个支持 gzip 的浏览器，此时代理会使用其未经压缩的缓存进行响应，于是就失去进行压缩的机会；

为解决这一问题，Web 服务器可在响应中添加 Vary 头，告诉代理根据一个或多个请求头来改变缓存；
例如，
```
Vary: Accept-Encoding
```
这将使得代理缓存响应的多个版本，Accept-Encoding 为 gzip 时的压缩内容和非压缩内容

### 第 5 章 将样式表放在顶部

根据浏览器渲染机制，使用样式表时，页面逐步呈现会被阻止直至所有样式表下载完成；

白屏：当样式表放在文档底部时，由于样式表未下载完，所以页面出现空白现象，也就是所谓的 "白屏“

FOUC：不同浏览器的渲染机制不一样，有些浏览器会逐步呈现，因此当样式在底部时，已经渲染的样式会被后面的样式所覆盖，这就是无样式内容闪烁现象；

因此，建议将样式表放在 HEAD 标签

[注] 这块涉及浏览器渲染原理

### 第 6 章 将脚本放在底部

【注】HTTP 1.1 规范建议浏览器从每个主机名并行下载两个组件
前端工程师预期依赖用户来修改浏览器设置，不如简单的使用 CNAME（DNS 别名）来将组件分别放到多个主机名中；

增加并行下载数量优劣取决于你的带宽和 CPU 速度，过多的并行下载反而会降低性能；

然而，下载脚本时并行下载是被禁用的，即使使用了不同的主机名，因为脚本可能会操作 DOM ，因此浏览器会等待以确保页面正确布局；
另一个原因是保证脚本按照正确的顺序执行；

### 第 7 章 避免 CSS 表达式

CSS expression 是 IE 的私有属性，并且 IE 8 以上将不再支持，故目前没有参考价值；

### 第 8 章 使用外部 JS 和 CSS

使用外部 JS 和 CSS 的关键点在于外部文件可以进行缓存，而 HTML 通常是不会被配置缓存的，因此如果将所有的 JS 和 CSS 进行内联，那么久无法利用缓存优势；

当然，在将 JS 和 CSS 打包到外部文件时，值得思考其打包策略：每个页面对应单独文件还是将所有 JS 和 CSS 打包到一个文件；

二者的区别在于：
每个页面对应单独文件好处是不会加载其他页面的资源，按需加载当前页面的资源，缺点是当访问其他页面时会增加 HTTP 请求；
该策略比较适合用户通常只访问一个页面或是很少跨页面访问

而每个页面对应单独文件则是请求量会大大减少，但是初次请求是的资源体量较大， 并且一旦某个页面的资源发生更新，整个打包文件需要跟着改变；
该策略使用于用户在一个会话中访问多个不同的页面；

#### 动态内联

Web 服务器可以通过 Cookie 识别一个页面的组件是否在浏览器缓存中，如果没有则采用 Post-Onload Download 技术，即加载后下载，先将 JS 和 CSS 内联在页面，并且页面加载后再下载 JS 和 CSS 并缓存起来；
![image.png](http://upload-images.jianshu.io/upload_images/1993435-04a5c579ff074b66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
下次访问时，根据 Cookie 直接生成一个使用外部文件的页面；

值得注意的是，基于会话的 Cookie 技术在内联时会发生错误，即组件已经缓存在浏览器中，但是如果用户 Cookie 重新打开浏览器，Cookie 就会消失，但是组件依然存在于缓存中，导致 Cookie 状态和缓存状态不匹配；

可以通过将 Cookie 从基于会话改为短期以解决这一问题；

### 第 9 章 减少 DNS 查找

通常，浏览器查找一个给定的主机名的 IP 地址后才能从主机名所在的 Web 服务器获取到对应的资源，DNS 的查找依赖于 DSN 解析器、它所承担的请求压力、距离以及带宽等；

当用户请求一个主机名后，DNS 信息会留在 DNS 缓存和浏览器缓存中，但是重新启动浏览器通常会清空浏览器缓存；

当客户端的 DNS 缓存为空时，DNS 查找数量与 Web 页面中的唯一主机名数量相等；
减少唯一主机名数量就能减少 DNS 查找数量，但是也会潜在地减少页面中并行下载的数量，二者在响应时间上是对立的；
因此需要在减少 DNS 查找和允许高度并行下载之间做出权衡；

【注】
IP、主机名和域名

### 第 10 章 精简 JavaScript

对 JS 的代码优化包括精简和混淆；

精简是从代码中移除不必要的字符以减小其大小，通常移除所有的注释和空白字符；

混淆是在精简的基础上进一步的改写代码，将函数和变量的名字转换为更短的字符串使得代码更加精炼，也更加难阅读。通常这是为了增加对代码进行反向工程的难度，同时在一定程度上提高性能；

值得注意的是，混淆有一下缺点：调试上的困难，JS 符号的改变是的代码变得面目全非；混淆本身有可能引入错误；

一般而言，通过之前的 gzip 将代码进行压缩产生的影响更加显著，但是精简 JS 代码也能进一步减小文件大小；

【注】当然精简 CSS 也能带来一定的效果，但是效果没有 JS 来的那么显著，因为 CSS 的注释和空白以及代码量比 JS 小；

### 第 11 章 避免重定向

重定向的缺点在于在用户和 HTML 文档中插入重定向延迟页面中的所有资源的呈现；


#### 使用重定向的动机

连接网站：将旧网站连接到新网站通常使用重定向；

跟踪内部流量：重定向经常用于追踪用户流量流向，很多导航链接呗重定向包装；
【注】
除了使用重定向追踪流量去向，也可以使用 Referer 请求头去追踪，但这个方法只适用于同一家公司的各个网站之间的流量，其他公司则不可能分析流量去向的 Referer 日志；

美化 URLs：使用重定向还可以是 URLs 更加美观和便于记忆，例如 http://google.com 比 http://google.com/ 美观；

### 第 12 章 移除重复脚本

重复脚本的产生是由于多人协作和脚本数量大所产生的一种失误，重复的脚本可能导致重复的 HTTP 请求和代码的重复执行；

### 第 13 章 配置 ETag

ETag（Entity Tag），实体标签是 Web 服务器和浏览器用于确认缓存组件的有效性的一种机制；

首先说一下组件是如何被缓存和确认的，浏览器下载组件时，会将他们缓存；
在后续的页面查看中，如果缓存的组件未过期，则浏览器从磁盘上读取它而避免 HTTP 请求，判断它是否过期的依据可通过 Expires 或是 Last_modified；

如果缓存组件过期，浏览器在重用它之前必须首先检查它是否仍然有效，于是发送一个条件请求，如果没有过期则返回 304 Not Modified；过期则获取最新资源；

服务器在检测缓存组件是否和原服务器上的组件匹配时有两种方式：

- 比较最新的修改日期：Last-Modified
当浏览器发送一个新请求时，服务器返回带有 Last-Modified 头的报文；
当浏览器再次发送一个请求时，会带上 If-Modified-Since 头，服务器接收报文后，如果发现资源更新则返回最新资源，否则返回 304；

- 比较实体标签：ETag 能够检测浏览器缓存中的组件是否与服务器上的组件是否匹配，ETag 是唯一标识一个组件的特定版本的字符串，但是不同的服务器在构造 ETag 时不同，并且 ETag 往往与特定服务器的属性相关，也就是说同一个组件在不同的服务器可能有不同的 ETag，这就造成缓存机制的失效可能性；

因此，在实践中，如果要使用 ETag 进行缓存的话，那么最好从 ETag 移除代表不同服务器属性的 ChangeNumber 或者完全移除 ETag 以避免数据已存在于浏览器缓存时进行不必要的请求；

### 第 14 章 使 Ajax 请求缓存

---

