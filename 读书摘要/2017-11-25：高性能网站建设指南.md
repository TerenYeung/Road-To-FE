## 高性能网站建设指南

### 本书主旨

阐明如何通过修改前端来改善网站性能

### 灵活运用

本书介绍 14 个性能优化规则，但是并非每个规则都要应用于每个网站，也不是每个网站都应该按照同一种方式运行一个规则，但每个规则都值得考虑；

### 绪言

#### 前端性能的重要性

事实上，通常只有 10% ~ 20% 的最终用户响应时间是花在从 Web 服务器获取 HTML 文档并传送到浏览器中的。
如果希望有效减少页面的响应时间，必须关注剩余 80% ~ 90% 的最终用户体验；

而仅需花费 10% ~ 20% d的响应时间来下载 HTML 文档，80% ~ 90% 的时间花费在页面的组件上；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-a2bfdf187a7ffe4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 第 1 章 减少 HTTP 请求

性能黄金法则揭示：只有 10% ~ 20% 的响应时间花费在接收所请求的 HTML 文档上，80% ~ 90% 的时间花费在为 HTML 文档所引用的组件（图片、脚本、样式表和 Falsh）上进行的 HTTP 请求上。

因此，改善响应时间的最简单途径就是减少组件的数量，由此就是减少 HTTP 请求的数量。

#### 图片地图 Image Maps

对于特定的小图片，可以使用图片地图技术将多张图片整合为一张以此减少 HTTP 请求；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-3daac0808e385efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

图片地图有两种类型：
- 服务器端图片地图
原理是将所有点击提交到同一个 URL ，然后传入用户点击的 x、y 坐标，Web 应用程序将其映射为适当的操作；

- 客户端图片地图
原理是通过 MAP 标签构建出不同矩形的区域，通过点击不同的区域映射不同的操作；

![image.png](http://upload-images.jianshu.io/upload_images/1993435-ba1229e8fbcf8e99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

图片地图的缺点是：

在定义图片地图的区域坐标时，采用手工方式很容易出错，并且只能定义矩形的形状；
同时，图片地图要求各个图片必须连续，一旦图片发生改变，需要修改整个图；

#### CSS Sprites

CSS Sprites 的原理是将多张小图整合为一张合成图，然后通过给不同元素设置 **background-position** 去指定 CSS Sprites 的偏移量；

#### 内联图片 Inline Images

通过 data: URL 模式可以在 Web 页面中包含图片而无需额外的 HTTP 请求；

其格式为：
```
data:[<mediatype>][;base64],<data>
```

![image.png](http://upload-images.jianshu.io/upload_images/1993435-dd389f6f9b859487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

由于 data: URL 内联在页面中，在切换不同页面时不会缓存，所以一些变动不大的图片，如（公司 Logo），一般是使用 外部 CSS 并将内联图片作为背景；

虽然将内联图片放置在外部样式表中额外增加一个 HTTP 请求，但被缓存后可以得到额外的收益；

#### 合并脚本和样式表

如果将脚本和样式表分开到多个小文件，则每个文件都需要一个额外的 HTTP 请求，因此可以将这些单独的文件合并到一个文件中，减少 HTTP 请求以缩短最终的用户响应时间；

【注】对于 SPA 而言，由于 JS 的体量较大，在加载脚本时可能会让用户响应时间过长，因此出现了另一种分离脚本的技术，即按需加载；

### 第 2 章 使用内容分发网络

通过 HTTP 请求的响应时间也和 Web 服务器距离用户地理位置的距离相关；
但是，不要尝试使用分布式架构重新设计 Web 应用程序，因为这回带来复杂、繁重的任务，比如同步会话状态和服务器纺织地点之间复制数据库事务等；

因此，与其重新设计应用程序这一艰难任务，以便应用程序 Web 服务器分散开，不如将组件 Web 服务器分散开，CDN 就是为了满足这一需求产生的；

CDN 是一组分布在多个不同地理位置的 Web 服务器，用于更加有效地向用户发布内容。

#### 优点
CDN 除了可以缩短响应时间外，还可以备份、扩展存储能力和进行缓存；

#### 缺点
CDN 服务提供商向所有客户共享其 Web 服务器组，因此你的响应时间可能受到其他人的影响；

你无法直接控制组件服务器从而带来特殊麻烦，比如修改 HTTP 响应头需要通过服务提供商；

### 第 3 章 缓存控制

本章节介绍如何配置组件，使其能够最大化地利用浏览器缓存能力来改善页面性能；

Web 服务器使用 Expires 响应头来告诉 Web 客户端它可以使用组件的当前副本，直到指定时间为止；
Expires 头能够使得浏览器在后续遇到相同的请求时发现资源未过期，由此 HTTP 请求数量减少一个；
Expires 头的缺点在于使用了一个特定的时间，这要求服务器和客户端的时钟严格保持同步；

另一种方式是通过 Cache-Control: max-age=xxx 来指定组件被缓存多久，具体讲师是第一次被请求时服务器记录的Request_time;

但是 Cache-Control 是 HTTP 1.1 版本提供的响应头，因此为了向后兼容，可以同时指定 Expries 和 Cache-Control，如果同时出现，则 max-age 指令重写 Expries 头；

### 第 4 章 压缩组件

本章介绍如何使用 gzip 编码来压缩 HTTP 响应报，并由此减少网络响应时间；

gzip 是目前最流行和最有效的压缩方法，是 GNU ;

Web 客户端通过 HTTP 请求头中的 Accept-Encoding 来标识对压缩的支持
```
Accept-Encoding: gzip;deflate
```
Web 服务器通过响应头中 Content-Encoding 来通知 Web 客户端：
```
Content-Encoding: gzip
```

通常，包括 HTML、XML、JSON 在内的文本以及脚本和样式表都是值得压缩的，而图片和 PDF 不应该压缩因为它们本来就已被压缩，再次压缩只会浪费 CPU 资源还有可能增加文件大小；

#### 代理缓存

当浏览器通过代理来发送请求，情况就变得复杂；

假设一个请求发送到代理是来自不支持 gzip 的浏览器，代理会将请求转发给 Web 服务器，此时服务器的响应是未经压缩的；

现在，到达代理的第 2 个请求访问的是同一个 URL，但来自一个支持 gzip 的浏览器，此时代理会使用其未经压缩的缓存进行响应，于是就失去进行压缩的机会；

为解决这一问题，Web 服务器可在响应中添加 Vary 头，告诉代理根据一个或多个请求头来改变缓存；
例如，
```
Vary: Accept-Encoding
```
这将使得代理缓存响应的多个版本，Accept-Encoding 为 gzip 时的压缩内容和非压缩内容

### 第 5 章 将样式表放在顶部

根据浏览器渲染机制，使用样式表时，页面逐步呈现会被阻止直至所有样式表下载完成；

白屏：当样式表放在文档底部时，由于样式表未下载完，所以页面出现空白现象，也就是所谓的 "白屏“

FOUC：不同浏览器的渲染机制不一样，有些浏览器会逐步呈现，因此当样式在底部时，已经渲染的样式会被后面的样式所覆盖，这就是无样式内容闪烁现象；

因此，建议将样式表放在 HEAD 标签

[注] 这块涉及浏览器渲染原理

### 第 6 章 将脚本放在底部

【注】HTTP 1.1 规范建议浏览器从每个主机名并行下载两个组件
前端工程师预期依赖用户来修改浏览器设置，不如简单的使用 CNAME（DNS 别名）来将组件分别放到多个主机名中；

增加并行下载数量优劣取决于你的带宽和 CPU 速度，过多的并行下载反而会降低性能；

然而，下载脚本时并行下载是被禁用的，即使使用了不同的主机名，因为脚本可能会操作 DOM ，因此浏览器会等待以确保页面正确布局；
另一个原因是保证脚本按照正确的顺序执行；




