## 高性能网站建设进阶指南

### 本书结构

- JavaScript 性能：1~7 章
- 网络性能：8~12 章
- 浏览器性能：13-14 章

### 第 1 章 理解 Ajax 性能

> 过早的优化是万恶之源

当我们做性能优化时，不要浪费时间去尝试那些不消耗大量时间的代码；

浏览器通常在运行 JS 上费时较少，绝大部分时间消耗在 DOM 上；

### 第 2 章 创建快速响应的 Web 应用

#### 浏览器用户界面的工作原理

当用户和浏览器交互时，操作系统接收到和计算机连接的各个设备的输入；
在判断哪个应用应接收这些输入后，将它们打包为单独事件放置到该应用的事件队列中；
浏览器按队列顺序完成其队列中单独事件的处理，这一处理过程实质上是单线程的，即浏览器每次只能处理这些任务的一个，任意一个任务都能阻止其他任务执行；

#### 线程处理

由于 JavaScript 不支持多线程，所以一定遇到 CPU 密集型任务时，用户界面就会出现停滞状态；

传统的解决方案是使用多线程把开销很大的代码从与用户交互线程中剥离出来，但是多线程的基本问题是不同的线程可以访问并修改相同的变量由此会产生竞争状态；

因此，需要一种像多线程那样能多任务并发执行却没有线程之间相互侵入危险的方法；

Web Worker 提供这种技术支持；

假设有一个 CPU 密集型任务：解密
```
// UI 文件

let worker = new Worker('js/decrypt.js')

// 注册事件处理程序，当 worker 给主线程发送信息时执行

worker.onmessage = function(e) {
  console.log('the decrypted value is', e.data)
}

// 发送信息给 worker，这里是待解密的值
worker.postMessage(getValueToDecrypt())

// js/decrypt.js
// 注册用来接收来自主线程信息的处理程序
onmessage = function(e) {
  let valueToDecrypt = e.data

  // TODO: 实现解密功能

  postMessage(decryptedValue)
}
```

由此，我们得知将 CPU 密集型任务分派给 Worker 去做，主线程继续响应 UI；

#### 内存使用对响应时间的影响

创建快速响应网页的另一个关键方面是：内存管理；

JavaScript 像许多现代高级语言一样把低级的内存管理抽象出来，实现垃圾回收功能；

然而，自动内存管理是有开销的，当执行回收时，GC 会 'stop the world'，即冻结真个运行环境，直到遍历完整个创建对象的”堆“，在这一过程，它们查找并回收未使用内存的对象；

虽然冻结运行环境的时间短到可以完全避开用户注意，但是随着应用程序内存占用的增加，遍历整个堆的时间会越来越长而最终引起用户注意；

一旦确定内存有问题，可从尚未清理内存的地方寻找解决问题的机会，如：

使用 delete 关键字从内存中删除不需要对象；
从网页的 DOM Tree 中移除不再需要的节点；

- 虚拟内存

### 第 3 章 拆分初始化负载

Ajax + DHTML 的日益普及使得 Web 应用愈像桌面应用程序，但是一般的 Web 应用程序在加载初期有很大一部分代码不会启动；

而高级的桌面应用程序采用的是插件式架构，允许动态加载模块，因此 Web 应用可以在加载代码时，可以进行拆分成两部分：一部分是渲染初始页面时必需的，另一部分是 post-onload 加载的；

接下来，我们要思考以下几个问题：

- 如何找到需要拆分的代码？

一些浏览器的 JavaScript 性能分析器能够显示出触发 onload 事件之前所有已执行的函数名，这可以帮助我们将 JavaScript 拆分成两个文件，一个用于页面初始化，另一个用于延迟加载，当然还包括一些错误处理和条件判断的代码，在此期间还要避免未定义标识符的错误；

- 怎么处理竞争状态？

如果用户在延迟加载的代码之前进行用户交互，有可能会触发未定义标识符的错误，解决方案如下：

在特定组件添加‘加载中’的图标

延迟加载该组件的事件处理程序

使用桩函数解决问题，桩函数是一个与原函数名相同但函数体为空的函数，作用是临时顶替原函数；

- 如何延迟加载其余部分代码？

### 第 4 章 无阻塞加载脚本

### 第 5 章 整合异步脚本

当前脚本加载的一种趋势：并行加载，顺序执行；






